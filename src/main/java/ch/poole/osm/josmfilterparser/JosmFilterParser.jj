/**
 * Parser for JOSM filter expressions
 *
 * @author Simon Poole
 *
 * Copyright (c) 2019, 2020 Simon Poole
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 * and associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies
 * or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
 * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
 " OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

options
{
  JDK_VERSION = "1.8";

  static = false;

  LOOKAHEAD= 255;
  IGNORE_CASE = true;
  FORCE_LA_CHECK = true;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 2;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(JosmFilterParser)
package ch.poole.osm.josmfilterparser;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.io.ByteArrayInputStream;
import java.util.Locale;
import java.util.Stack;

public class JosmFilterParser
{
  Stack < Boolean > startParen = new Stack < Boolean > ();

  boolean regexp = false;

  Condition condition() throws ParseException {
    return condition0(false);
  }

  Condition condition(boolean regexp) throws ParseException {
    return condition0(regexp);
  }

  void unsupported(String thing) throws ParseException
  {
    ParseException pex = new ParseException("\"" + thing + "\" is unsupported " + token.next.beginLine + ", column " + token.next.beginColumn);
    pex.currentToken = token;
    throw pex;
  }
  Condition not(Token notToken, Condition condition)
  {
    return notToken == null ? condition : new Not(condition);
  }
}

PARSER_END(JosmFilterParser)

TOKEN_MGR_DECLS :
{
  int bracketNestingDepth;
  Stack < Integer > state = new Stack < Integer > ();
}

< DEFAULT, LITERAL_STRING_STATE >
TOKEN :
{
  < CHAR : ~[ "-", "\"", "\\", "|", " ", "\t", "<", "=", ">", ":", "(", ")" ] > : LITERAL_STRING_STATE
}

< FRAGMENT_STRING_STATE >
TOKEN :
{
  < FRAGMENTCHAR : ~[ "\"", "\\", "|", " ", "\t", "<", "=", ">", "(", ")" ] > : FRAGMENT_STRING_STATE
}

< DEFAULT, FRAGMENT_STRING_STATE >
TOKEN :
{
  < QUOTE : "\"" >
  {
    state.push(curLexState);
  }
  : QUOTED_STRING_STATE // save current state
}

< QUOTED_STRING_STATE >
TOKEN :
{
  < ENDQUOTE : < QUOTE > >
  {
    SwitchTo(state.pop());
  } // need to switch to prev state 
| < QUOTED_STRING_CHAR : ~[ "\"", "\\" ] >
}

< DEFAULT, LITERAL_STRING_STATE, FRAGMENT_STRING_STATE >
TOKEN :
{
  < WS_COND : [ " ", "\t" ] > : DEFAULT
}

< DEFAULT >
TOKEN :
{
  < AND : "AND" >
| < OR : "OR" >
| < MINUS : "-" >
}

< DEFAULT, LITERAL_STRING_STATE >
TOKEN :
{
  < BAR : "|" > : DEFAULT
| < EQ : "=" > : DEFAULT
| < GT : ">" > : DEFAULT
| < LT : "<" > : DEFAULT
| < DOUBLECOLON : ":" > : FRAGMENT_STRING_STATE
}

< DEFAULT, LITERAL_STRING_STATE >
TOKEN :
{
  < LPAREN : "(" >
  {
    bracketNestingDepth += 1;
  }
  : DEFAULT
| < RPAREN : ")" >
  {
    bracketNestingDepth -= 1;
  }
  : DEFAULT
}

/**
 * Match a value
 */
String literal() :
{
  StringBuilder builder = new StringBuilder();
}
{
  (
    getChar(builder)
  )+
  {
    return builder.toString().trim();
  }
}

/**
 * Add char to StringBuilder
 */
void getChar(StringBuilder builder) :
{
  Token t;
  String s;
}
{
  (
    (t = < CHAR >)
    {
      if (t.image.length() == 1)
      {
        // CHAR
        builder.append(t.image.charAt(0));
      }
    }
  | 
    s = quotedLiteral()
    {
      builder.append(s);
    }
  )
}

/**
 * Match a value
 */
String fragmentLiteral() :
{
  StringBuilder builder = new StringBuilder();
}
{
  (
    getFragmentChar(builder)
  )+
  {
    return builder.toString().trim();
  }
}

/**
 * Add char to StringBuilder
 */
void getFragmentChar(StringBuilder builder) :
{
  Token t;
  String s;
}
{
  (
    (t = < FRAGMENTCHAR >)
    {
      if (t.image.length() == 1)
      {
        // CHAR
        builder.append(t.image.charAt(0));
      }
    }
  | 
    s = quotedLiteral()
    {
      builder.append(s);
    }
  )
}

/**
 * Match char inside quoted string.
 */
void getQuotedStringChar(StringBuilder builder) :
{
  Token t;
  String s;
}
{
  (
    (t = < QUOTED_STRING_CHAR >)
    {
      if (t.image.length() < 2)
      {
        // CHAR
        builder.append(t.image.charAt(0));
      }
    }
  | 
    s = quotedLiteral()
    {
      builder.append(s);
    }
  )
}

/**
 * Match a quoted string.
 */
String quotedLiteral() :
{
  StringBuilder builder = new StringBuilder();
}
{
  (
  < QUOTE >
  )
  (
    getQuotedStringChar(builder)
  )*
  < ENDQUOTE >
  {
    return builder.toString();
  }
}

/**
 * This is fairly convoluted to avoid left recursion 
 */
Condition combination() :
{
  Condition r1;
  Condition r2;
  Condition result = null;
  Token not1 = null;
  Token not2 = null;
  Token child = null;
}
{
  (
    (< WS_COND >)*
    (
      (
        (
        not1 = < MINUS >
        )?
        (
          r1 = match()
        )
        {
          result = r1;
        }
        (< WS_COND >)+ 
        (
        not2 = < MINUS >
        )?
        (
          r2 = match()
        )
        {
          result = new And(not(not1, r1), not(not2, r2));
        }
      )
    |
      (
        (
          (
          not1 = < MINUS >
          )?
          (
            r1 = match()
          )
          {
            result = r1;
          }
          (
            (
              (< WS_COND >)+ 
              < OR > 
              (< WS_COND >)+
            )
          |
            (
              (< WS_COND >)* 
              < BAR > 
              (< WS_COND >)*
            )
          )
          (
          not2 = < MINUS >
          )?
          (
            r2 = match()
          )
        )
        {
          result = new Or(not(not1, r1), not(not2, r2));
        }
      )
    |
      (
        (
        not1 = < MINUS >
        )?
        (
          r1 = match()
        )
        {
          result = not(not1, r1);
        }
      )
    |
      (
        (
          (
          not1 = < MINUS >
          )? 
          < LPAREN > 
          r1 = combination() 
          (< WS_COND >)* 
          < RPAREN >
        )
        {
          result = not(not1, new Brackets(r1));
        }
      )
    )
    (
      (
        (
          (< WS_COND >)+ 
          (
          not2 = < MINUS >
          )?
          (
            r2 = match()
          |
            (
              (
                < LPAREN > 
                r2 = combination() 
                (< WS_COND >)* 
                < RPAREN >
              )
              {
                r2 = new Brackets(r2);
              }
            )
          )
          {
            result = new And(result, not(not2, r2));
          }
        )
      |
        (
          (
            (
              (< WS_COND >)+ 
              < OR > 
              (< WS_COND >)+
            )
          |
            (
              (< WS_COND >)* 
              < BAR > 
              (< WS_COND >)*
            )
          )
          (
          not2 = < MINUS >
          )?
          (
            r2 = match()
          |
            (
              (
                < LPAREN > 
                r2 = combination() 
                (< WS_COND >)* 
                < RPAREN >
              )
              {
                r2 = new Brackets(r2);
              }
            )
          )
        )
        {
          result = new Or(result, not(not2, r2));
        }
      )
    )*
  )
  {
    return result;
  }
}

Condition match() :
{
  String s1 = null;
  boolean s1Quoted = false;
  String s2 = null;
  boolean s2Quoted = false;
  Token op = null;
}
{
  (
    (
      (
        s1 = quotedLiteral()
      )
      {
        s1Quoted = true;
      }
    | 
      s1 = literal()
    )
    (
      (
        (
          (< WS_COND >)*
          (
            op = < EQ >
          | op = < GT >
          | op = < LT >
          )
          (< WS_COND >)*
        )
        (
          s2 = literal()
        |
          (
            s2 = quotedLiteral()
          )
          {
            s2Quoted = true;
          }
        )?
      )
    |
      (
        op = < DOUBLECOLON >
        (
          (
            s2 = quotedLiteral()
          )
          {
            s2Quoted = true;
          }
        | 
          s2 = fragmentLiteral()
        )
      )
    )?
  )
  {
    if (op != null && ":".equals(op.image))
    {
      if (s1Quoted)
      {
        return new ValueFragment(s1, s2);
      }
      else
      {
        switch (s1)
        {
          case "type" : return new ElementType(Type.valueOf(s2.toUpperCase()));
          case "preset" : return new Preset(s2);
          case "nodes" : return new Nodes(s2);
          case "ways" : return new Ways(s2);
          case "tags" : return new Tags(s2);
          case "members" : return new Members(s2);
          case "role" : return new Role(s2);
          case "areasize" : return new AreaSize(s2);
          case "waylength" : return new WayLength(s2);
          case "user" : return new User(s2);
          case "id" : return new Id(Long.parseLong(s2));
          case "version" : return new Version(Long.parseLong(s2));
          case "changeset" : return new Changeset(Long.parseLong(s2));
          case "timestamp" : return new ElementTimestamp(s2);
          case "hasRole" : return new HasRole(s2);
          case "nth" : unsupported(s1);
          case "nth%" : unsupported(s1);
          default : return new ValueFragment(s1, s2);
        }
      }
    }
    else
    {
      if (s1Quoted || op != null)
      {
        return new Match(s1, op == null ? null : op.image, s2, regexp);
      }
      else
      {
        switch (s1)
        {
          case "closed" : return new Closed();
          case "untagged" : return new Untagged();
          case "modified" : 
          case "new" : 
          case "deleted" : return new ElementState(ElementState.State.valueOf(s1.toUpperCase()));
          case "selected" : return new Selected();
          case "incomplete" : return new Incomplete();
          case "inview" : return new Inview();
          case "allinview" : return new AllInview();
          case "indownloadedarea" : return new InDownloadedArea();
          case "allindownloadedarea" : return new AllInDownloadedArea();
          default : return new Match(s1, null, null, regexp);
        }
      }
    }
  }
}

Condition condition0(boolean regexp) :
{
  Condition r;

  this.regexp = regexp;
}
{
  (
    r = combination()
  )
  < EOF >
  {
    return r;
  }
}

<* >
TOKEN :
{
  < UNEXPECTED_CHAR : ~[ ] >
}
