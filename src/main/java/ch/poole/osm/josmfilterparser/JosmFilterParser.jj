/**
 * Parser for JOSM filter expressions
 *
 * @author Simon Poole
 *
 * Copyright (c) 2019 Simon Poole
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 * and associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies
 * or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
 * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
 " OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

options
{
  JDK_VERSION = "1.7";

  static = false;

  LOOKAHEAD= 4;
  IGNORE_CASE = true;
  FORCE_LA_CHECK = true;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 2;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(JosmFilterParser)
package ch.poole.osm.josmfilterparser;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.io.ByteArrayInputStream;
import java.util.Locale;

public class JosmFilterParser
{
}

PARSER_END(JosmFilterParser)

TOKEN_MGR_DECLS :
{
  int bracketNestingDepth;
  int prevState;
}

TOKEN :
{
  < CHAR : ~[ "-", "\"", "\\", "|", " ", "\t", "<", "=", ">" ] >
}

TOKEN :
{
  < QUOTE : "\"" >
  {
    prevState = curLexState;
  }
  : QUOTED_STRING_STATE // save current state
}

< QUOTED_STRING_STATE >
TOKEN :
{
  < ENDQUOTE : < QUOTE > >
  {
    SwitchTo(prevState);
  } // need to switch to prev state 
| < QUOTED_STRING_CHAR : ~[ "\"", "\\" ] >
}

< CONDITION_STATE >
TOKEN :
{
  < CONDITION_QUOTE : "\"" >
  {
    prevState = curLexState;
  }
  : QUOTED_STRING_STATE // save current state
}

TOKEN :
{
 < WS_COND : [ " ", "\t" ] >
| < LPAREN : "(" >
  {
    bracketNestingDepth = 1;
  }
  : PAREN_STATE
| < DOUBLECOLON : ":" >
| < AND : "AND" >
| < OR : "OR" >
| < BAR : "|" >
| < EQ : "=" >
| < GT : ">" >
| < LT : "<" >
| < MINUS : "-" >
}

< PAREN_STATE >
TOKEN :
{
  < PAREN_QUOTE : "\"" >
  {
    prevState = curLexState;
  }
  : QUOTED_STRING_STATE // save current state
}

< PAREN_STATE >
TOKEN :
{
  < PAREN_LPAREN : "(" >
  {
    bracketNestingDepth += 1;
  }
| < RPAREN : ")" >
  {
    bracketNestingDepth -= 1;
    SwitchTo(bracketNestingDepth == 0 ? CONDITION_STATE : PAREN_STATE);
  }
| < PAREN_CHAR : ~[ "(", ")", "\"", "\\", " ", "\t", "<", "=", ">" ] >
| < WS_PAREN : [ " ", "\t" ] >
| < PAREN_AND : "AND" >
| < PAREN_EQ : "=" >
| < PAREN_GT : ">" >
| < PAREN_GTEQ : ">=" >
| < PAREN_LT : "<" >
| < PAREN_LTEQ : "<=" >
}

TOKEN :
{
  < STATE :
    "modified"
  | "new"
  | "selected"
  | "incomplete"
  | "deleted" >
  {
    matchedToken.image = image.toString().toLowerCase(Locale.US);
  }
}

TOKEN :
{
  < METADATA :
    "user"
  | "id"
  | "version"
  | "changeset"
  | "timestamp" >
  {
    matchedToken.image = image.toString().toLowerCase(Locale.US);
  }
}

TOKEN :
{
  < TYPE :
    "node"
  | "way"
  | "relation" >
  {
    matchedToken.image = image.toString().toLowerCase(Locale.US);
  }
}

TOKEN :
{
  < PROPERTIES :
    "nodes"
  | "ways"
  | "tags"
  | "role"
  | "areasize"
  | "waylength" >
  {
    matchedToken.image = image.toString().toLowerCase(Locale.US);
  }
}

TOKEN :
{
  < VIEW :
    "inview"
  | "allinview"
  | "indownloadedarea"
  | "allindownloadedarea" >
  {
    matchedToken.image = image.toString().toLowerCase(Locale.US);
  }
}

/**
 * Match a value
 */
String literal() :
{
  StringBuilder builder = new StringBuilder();
}
{
  (
    getChar(builder)
  )+
  {
    return builder.toString().trim();
  }
}

/**
 * Add char to StringBuilder
 */
void getChar(StringBuilder builder) :
{
  Token t;
  String s;
}
{
  (
    (t = < CHAR >)
    {
      if (t.image.length() < 2)
      {
        // CHAR
        builder.append(t.image.charAt(0));
      }
    }
  | 
    s = quotedLiteral()
    {
      builder.append(s);
    }
  )
}

/**
 * Match char inside quoted string.
 */
void getQuotedStringChar(StringBuilder builder) :
{
  Token t;
  String s;
}
{
  (
    (t = < QUOTED_STRING_CHAR >)
    {
      if (t.image.length() < 2)
      {
        // CHAR
        builder.append(t.image.charAt(0));
      }
    }
  | 
    s = quotedLiteral()
    {
      builder.append(s);
    }
  )
}

/**
 * Match a quoted string.
 */
String quotedLiteral() :
{
  StringBuilder builder = new StringBuilder();
}
{
  (
    < QUOTE >
  | < CONDITION_QUOTE >
  | < PAREN_QUOTE >
  )
  (
    getQuotedStringChar(builder)
  )*
  < ENDQUOTE >
  {
    return builder.toString();
  }
}

/**
 * Match char inside parenthesis 
 */
void getParenChar(StringBuilder builder) :
{
  Token t;
  String s;
}
{
  (
    (
      t = < PAREN_CHAR >
    | t = < WS_PAREN >
    )
    {
      if (t.image.length() < 2)
      {
        // CHAR
        builder.append(t.image.charAt(0));
      }
    }
  | 
    s = quotedLiteral()
    {
      builder.append(s);
    }
  )
}

Condition combination() :
{
  Condition r1;
  Condition r2;
}
{
  (
    (
      r1 = match()
      (
        (
          ( < WS_COND > )+
          (
            r2 = match()
          | r2 = combination()
          )
          {
            return new And(r1, r2);
          }
        )
      |
        (
          ( < WS_COND > )+
          (
            < OR >
          | < BAR >
          )
          (
          < WS_COND >)+
          (
            r2 = match()
          | r2 = combination()
          )
        )
        {
          return new Or(r1, r2);
        }
      )?
    )
    {
      return r1;
    }
  |
    (
      < MINUS > r1 = condition()
      {
        return new Not(r1);
      }
    )
  )
}

Condition match() :
{
  String s1 = null;
  String s2 = null;
  Token op = null;
}
{
  (
    (
      s1 = literal()
    | s1 = quotedLiteral()
    )
    (
      (< WS_COND >)*
      (
        op = < EQ >
      | op = < GT >
      | op = < LT >
      | op = < DOUBLECOLON >
      )
      (
        (< WS_COND >)* 
        s2 = literal()
      | s2 = quotedLiteral()
      )
    )?
  )
  {
    return new Match(s1, op == null ? null : op.image, s2);
  }
}

Condition condition() :
{
  Condition r;
}
{
  (
   r = combination()
  )
  < EOF >
  {
    return r;
  }
}

<* >
TOKEN :
{
  < UNEXPECTED_CHAR : ~[ ] >
}
